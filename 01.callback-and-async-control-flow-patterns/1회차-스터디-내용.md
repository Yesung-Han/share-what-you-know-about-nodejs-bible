# 1회차 스터디 내용

## 콜백(비동기) 코드의 가독성을 개선했던 경험

- callback hell 가 많아서 코드가 복잡해지고, 유지보수가 어려웠다. 이 후 thenable 스타일을 지원하는 bluebird 라이브러리를 사용하면서 코드의 뎁스가 줄었다. 그 다음으로 promise, async, await 표준으로 나와서 코드가 더 간결해졌다.
- callback 코드를 promise 로 감싸거나, promisify 해서 사용한다.
```ts
await Promise.promisify(fs.readFile)(path, 'utf8');

await Promise( (resolve, reject) => {
    someAsyncFunction((err, result) => {
        if (err) {
            reject(err);
        } else {
            resolve(result);
        }
    });
})
```

## 비동기 처리 경험

- 오래 걸리는 작업을 api로 제공하는것이 올바른 설계가 아니라고 생각한다. API 는 수초내 빠른 응답을 할 수 있도록 설계해야 한다.
- 공유 저장소를 두고 특정 시점 마다 작업의 상태를 저장하도록 했다.
- 클라이언트 풀링을 개선하고자 소켓 서버를 두고 작업의 진행 상태를 푸시 받을수 있도록 구성했다.
- 서버to서버 상황에서 요청시 작업의 결과를 전달받을 uri 을 요청에 포함시키도록 하여 비동기 작업 완료시 콜백형태로 받을수 있도록 구성했다.
- 메시지큐와 같은 시스템을 사용하는게 가장 좋지만 소규모 서비스에서는 비용, 복잡도를 고려했을때 가성비가 좋지 못해서 보통 풀링 방식을 많이 선택했다.

## event emitter 와 같은 이벤트 드리븐 패턴의 코드 작성 경험

- 코드의 흐름을 눈으로 읽기 힘들어서 가독성이 떨어지는 느낌을 받았다.
- 히스토리를 모르면 운영, 유지 보수 하기 힘들었다.
- 대부분의 서비스가 멀티 인스턴스로 구성되니 node 내장 라이브러리인 eventEmiiter 를 사용할 일이 없었고 redis,kafka 같은 메시지 큐를 사용했다.
- 관심사를 분리하고 싶을때 사용했다. (예를들어 로그를 남기는 로직을 분리하고 싶을때)

## libuv 의 동작의 이해

- 이벤트 루프가 스텍에서 작업을 꺼내어 실행하는데 이때 싱글스레드니 하나씩 수행한다라는 점을 인지한 상태에서 이해하려고 하면 쉬웠다.
- https://www.youtube.com/watch?v=8aGhZQkoFbQ 이 영상을 통해서 이해하기 쉬웠다.
- https://kkangdda.tistory.com/77 이 블로그 도 굳굳
- UV_THREADPOOL_SIZE 값을 조절하면 커널에서 지원하지 않는 비동기 작업의 처리의 동시 처리 성능을 개선할수 있다. ( 단 커널에서 지원하는 비동기 작업의 경우 이 옵션을 조절해도 의미가 없다. )
- setTimeout, setInternal 이 정확히 특정 시점에 코드 수행을 보장하지 못하는 이유를 libuv, 이벤트 루프 동작 이해를 통해서 알수있었다.

아래꺼는 코파일러이 써주길래 넣어봤어요 ㅋㅋㅋ
- libuv 에서는 이벤트 루프를 통해 비동기 작업을 처리한다. 이벤트 루프는 스택에 콜백을 넣고 실행한다. 이때 스택이 비어있으면 이벤트 루프는 큐에서 콜백을 꺼내서 실행한다. 이때 큐에는 타이머, I/O,
  이벤트 등이 있다. 이벤트 루프는 이벤트 큐에 콜백을 넣고 실행한다. 이때 이벤트 큐에는 타이머, I/O, 이벤트 등이 있다. 이벤트 루프는 이벤트 큐에 콜백을 넣고 실행한다. 이때 이벤트 큐에는 타이머,
  I/O, 이벤트 등이 있다. 이벤트 루프는 이벤트 큐에 콜백을 넣고 실행한다. 이때 이벤트 큐에는 타이머, I/O, 이벤트 등이 있다. 이벤트 루프는 이벤트 큐에 콜백을 넣고 실행한다. 이때 이벤트 큐에는
  타이머, I/O, 이벤트 등이 있다. 이벤트 루프는 이벤트 큐에 콜백을 넣고 실행한다. 이때 이벤트 큐에는 타이머, I/O, 이벤트 등이 있다. 이벤트 루프는 이벤트 큐에 콜백을 넣고 실행한다. 이때 이벤트
  큐에는 타이머, I/O, 이벤트 등이 있다. 이벤트 루프는 이벤트 큐에 콜백을 넣고 실행한다. 이때 이 이벤트 루프는 이벤트 큐에 콜백을 넣고 실행한다. 이때 이벤트 큐에는 타이머, I/O, 이벤트 등이 있다.

## I/O 처리를 향상 시키기 위한 경험
- Promise.all 을 사용해서 병렬로 처리하도록 했다.
- 너무 많은 작업을 병렬로 실행시키면 오히려 전체 성능이 더 저하된다. 적정 수준을 실험을 통해 찾는게 좋다.
- pm2 와 같은 도구를 이용하여 프로세스를 늘리거나 인스턴스 수를 늘렸다.
- 데이터베이스 작업이 엮여있는 작업의 경우 커넥션 풀 설정을 살펴봐야한다.
- http 요청 처리에서는 http-agent 의 옵션 ( 예를 들어 keep-alive, connection-timeout, 등) 옵션을 잘 조절해봐야한다.